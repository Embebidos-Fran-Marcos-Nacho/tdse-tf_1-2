MODO DE PRUEBA + LOGGER POR SERIAL UART (TA134)
===============================================

Objetivo
--------
Este modo permite validar por consola serial que el firmware:
1) recorre todas las tareas del scheduler,
2) atraviesa estados (Init/Normal/Fault),
3) procesa eventos de botón y potenciómetro,
4) detecta cruces por cero y dispara TRIACs con timestamp,
5) transmite datos de estado por Bluetooth.


1) Activar / desactivar modo prueba
-----------------------------------
Archivo:
  Software STM32/main/app/inc/app.h

Macro:
  #define APP_TEST_MODE (1)
  #define APP_TEST_SIMULATE_ZC (1)
  #define APP_TEST_WAVE_100HZ_PIN (1)

Valores:
  1 = logs de prueba activados
  0 = logs de prueba desactivados

Simulación de ZCD:
  APP_TEST_SIMULATE_ZC = 1 -> genera cruces por cero internos (100 Hz)
  APP_TEST_SIMULATE_ZC = 0 -> usa únicamente la interrupción real en PC2

Onda cuadrada en pin libre:
  APP_TEST_WAVE_100HZ_PIN = 1 -> genera 100 Hz en PC8
  APP_TEST_WAVE_100HZ_PIN = 0 -> PC8 queda en nivel bajo

Prueba de falla:
  En APP_TEST_MODE, poner DIP4 = 1 fuerza entrada a ST_FAULT.
  Esto permite validar LED/Buzzer de alarma sin provocar una falla real.


2) Logger: semihosting eliminado
--------------------------------
Ahora el logger usa UART (serial console), no semihosting.

Archivo:
  Software STM32/main/app/inc/logger.h

Configuración actual:
  LOGGER_CONFIG_USE_SEMIHOSTING = 0
  LOGGER_CONFIG_USE_UART = 1

El `main.c` ya NO llama a `initialise_monitor_handles()`.


3) Cómo ver los logs en Serial Console
--------------------------------------
El logger transmite por `USART2` (huart2), que en NUCLEO-F103RB
sale al USB del ST-Link como Virtual COM Port (VCP).

Pasos:
1. Conectar la NUCLEO por el USB del ST-Link a la PC.
2. Verificar en el administrador de dispositivos que aparece un COM
   de STMicroelectronics Virtual COM Port.
3. Abrir terminal serial (PuTTY, TeraTerm, RealTerm, etc.) sobre ese COM.
4. Configurar:
   - Baudrate: el configurado en `MX_USART2_UART_Init()` de `main.c`
   - 8 bits, sin paridad, 1 stop (8N1)
5. Resetear la placa y observar logs.

Importante:
- `USART1` queda libre para HC-05 (Bluetooth), por lo que logs y BT ya no se mezclan.
- Si no ves COM en PC, revisar drivers ST-Link y cable USB de datos.


4) Logs instrumentados
----------------------
- app.c
  - heartbeat scheduler + WCET:
    [APP] t=... cnt=... runtime=... wcet={...}

- task_adc.c
  - botón debounced:
    [ADC] EV_SYS_PRESSED ...
  - cambio de pote:
    [ADC] EV_POTE_CHANGED ...
  - heartbeat sensores:
    [ADC] heartbeat dip=... adc=... btn_ev=...

- task_system.c
  - transición de estado:
    [SYS] state -> ...
  - toggle luz:
    [SYS] toggle light=...
  - guardado en flash:
    [SYS] flash save light=... OK

- task_pwm.c
  - evento ZC:
    [PWM] ZC event ...
  - scheduling de disparo:
    [PWM] FAN/LIGHT schedule fire_at=...
  - firing TRIAC ON/OFF:
    [PWM] FAN/LIGHT FIRE ON/OFF ...
  - TX Bluetooth:
    [BT] TX {"adc":...,"light":...,"btCfg":...}


5) Prueba rápida sugerida (sin 220V)
------------------------------------
1. APP_TEST_MODE = 1.
2. Si APP_TEST_WAVE_100HZ_PIN = 1, medir PC8:
   - Debe verse cuadrada de ~100 Hz.
   - Podés puentear PC8 -> PC2 para excitar ZCD sin placa externa.
3. Si APP_TEST_SIMULATE_ZC = 1, no hace falta cablear nada:
   - Debe aparecer [PWM] ZC event + schedule + FIRE ON/OFF.
   Si APP_TEST_SIMULATE_ZC = 0, entonces simular ZC con pulsador en PC2.
4. Forzar ADC a 0V y 3.3V.
   - Debe cambiar adc% y delay del fan.
5. Presionar botón de luz.
   - Debe aparecer EV_SYS_PRESSED y toggle light.
6. Probar BT.
   - Debe aparecer [BT] TX en cambios de luz/pote.
7. Probar estado Fault (LED/Buzzer):
   - Poner DIP4 = 1 (solo APP_TEST_MODE).
   - Debe aparecer log: [SYS] test: DIP4=1 -> force ST_FAULT
   - Si DIP3=1, LED parpadea a 1 Hz en Fault.
   - Si DIP2=1, buzzer suena por PWM (~2 kHz) durante fase ON.


6) Volver a modo normal
-----------------------
1. Poner APP_TEST_MODE = 0.
2. Si no querés ningún log, poner LOGGER_CONFIG_ENABLE = 0.
3. Recompilar.


Nota útil
---------
LOGGER_CONFIG_MAXLEN está en 64 bytes.
Si un mensaje supera ese tamaño, se trunca.
